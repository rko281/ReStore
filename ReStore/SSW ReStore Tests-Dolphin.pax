| package |
package := Package name: 'SSW ReStore Tests-Dolphin'.
package paxVersion: 1;
	basicComment: 'ReStore
©2019 John Aspinall
https://github.com/rko281/ReStore'.


package classNames
	add: #DolphinTypeTest;
	add: #Where;
	yourself.

package methodNames
	add: #SimplePerson -> #friendSurnameOrNil;
	add: #SimplePerson -> #testIsNilJumpBytecodePattern1;
	add: #SimplePerson -> #testIsNilJumpBytecodePattern2;
	add: #SimplePerson -> #testIsNilJumpBytecodePattern3a;
	add: #SimplePerson -> #testIsNilJumpBytecodePattern3b;
	add: #SimplePerson -> #testIsNilJumpBytecodePattern4;
	add: #SimplePerson -> #testNotNilJumpBytecodePattern1;
	add: #SimplePerson -> #testNotNilJumpBytecodePattern2;
	add: #SimplePerson -> #testNotNilJumpBytecodePattern3a;
	add: #SimplePerson -> #testNotNilJumpBytecodePattern3b;
	add: #SimplePerson -> #testNotNilJumpBytecodePattern4;
	add: #SSWODBCStatement -> #freeIgnoringFinalizer;
	add: #SSWReStoreBlockAndOrQueryTest -> #note;
	add: #SSWReStoreDebugTest -> #evaluateIsInIDECallStackIn:;
	add: #SSWReStoreDebugTest -> #testBasicInspectorIsInIDECallStack;
	add: #SSWReStoreDebugTest -> #testDebuggerIsInIDECallStack;
	add: #SSWReStoreDebugTest -> #testFlipperInspectorIsInIDECallStack;
	add: #SSWReStoreDebugTest -> #testWorkspaceIsInIDECallStack;
	add: #SSWReStoreFullTableTest -> #test21VerifyLegacyNameTransformationMode;
	add: #SSWReStoreFunctionTest -> #testPlatformSpecificFunction;
	add: #SSWReStoreIsNilQueryTest -> #assertIsNilJumpBytecodePattern1:;
	add: #SSWReStoreIsNilQueryTest -> #assertIsNilJumpBytecodePattern2:;
	add: #SSWReStoreIsNilQueryTest -> #assertIsNilJumpBytecodePattern3a:;
	add: #SSWReStoreIsNilQueryTest -> #assertIsNilJumpBytecodePattern3b:;
	add: #SSWReStoreIsNilQueryTest -> #assertIsNilJumpBytecodePattern4:;
	add: #SSWReStoreIsNilQueryTest -> #assertMethodIsNilJumpBytecodePattern1:;
	add: #SSWReStoreIsNilQueryTest -> #assertMethodIsNilJumpBytecodePattern2:;
	add: #SSWReStoreIsNilQueryTest -> #assertMethodIsNilJumpBytecodePattern3a:;
	add: #SSWReStoreIsNilQueryTest -> #assertMethodIsNilJumpBytecodePattern3b:;
	add: #SSWReStoreIsNilQueryTest -> #assertMethodIsNilJumpBytecodePattern4:;
	add: #SSWReStoreIsNilQueryTest -> #testIsNilJumpBytecodePattern1;
	add: #SSWReStoreIsNilQueryTest -> #testIsNilJumpBytecodePattern2;
	add: #SSWReStoreIsNilQueryTest -> #testIsNilJumpBytecodePattern3a;
	add: #SSWReStoreIsNilQueryTest -> #testIsNilJumpBytecodePattern3b;
	add: #SSWReStoreIsNilQueryTest -> #testIsNilJumpBytecodePattern4;
	add: #SSWReStoreIsNilQueryTest -> #testMethodIsNilJumpBytecodePattern1;
	add: #SSWReStoreIsNilQueryTest -> #testMethodIsNilJumpBytecodePattern2;
	add: #SSWReStoreIsNilQueryTest -> #testMethodIsNilJumpBytecodePattern3a;
	add: #SSWReStoreIsNilQueryTest -> #testMethodIsNilJumpBytecodePattern3b;
	add: #SSWReStoreIsNilQueryTest -> #testMethodIsNilJumpBytecodePattern4;
	add: #SSWReStoreNotNilQueryTest -> #assertMethodNotNilJumpBytecodePattern1:;
	add: #SSWReStoreNotNilQueryTest -> #assertMethodNotNilJumpBytecodePattern2:;
	add: #SSWReStoreNotNilQueryTest -> #assertMethodNotNilJumpBytecodePattern3a:;
	add: #SSWReStoreNotNilQueryTest -> #assertMethodNotNilJumpBytecodePattern3b:;
	add: #SSWReStoreNotNilQueryTest -> #assertMethodNotNilJumpBytecodePattern4:;
	add: #SSWReStoreNotNilQueryTest -> #assertNotNilJumpBytecodePattern1:;
	add: #SSWReStoreNotNilQueryTest -> #assertNotNilJumpBytecodePattern2:;
	add: #SSWReStoreNotNilQueryTest -> #assertNotNilJumpBytecodePattern3a:;
	add: #SSWReStoreNotNilQueryTest -> #assertNotNilJumpBytecodePattern3b:;
	add: #SSWReStoreNotNilQueryTest -> #assertNotNilJumpBytecodePattern4:;
	add: #SSWReStoreNotNilQueryTest -> #testMethodNotNilJumpBytecodePattern1;
	add: #SSWReStoreNotNilQueryTest -> #testMethodNotNilJumpBytecodePattern2;
	add: #SSWReStoreNotNilQueryTest -> #testMethodNotNilJumpBytecodePattern3a;
	add: #SSWReStoreNotNilQueryTest -> #testMethodNotNilJumpBytecodePattern3b;
	add: #SSWReStoreNotNilQueryTest -> #testMethodNotNilJumpBytecodePattern4;
	add: #SSWReStoreNotNilQueryTest -> #testNotNilJumpBytecodePattern1;
	add: #SSWReStoreNotNilQueryTest -> #testNotNilJumpBytecodePattern2;
	add: #SSWReStoreNotNilQueryTest -> #testNotNilJumpBytecodePattern3a;
	add: #SSWReStoreNotNilQueryTest -> #testNotNilJumpBytecodePattern3b;
	add: #SSWReStoreNotNilQueryTest -> #testNotNilJumpBytecodePattern4;
	add: #SSWReStoreQueryTest -> #testQueryWithIfTrueMethodFollowedByOr;
	add: #SSWReStoreResourcesTest -> #_testStatementFinalizedAfter:;
	add: #SSWReStoreResourcesTest -> #_testStatementFreedAfter:;
	add: #SSWReStoreTableTest -> #test21VerifyLegacyNameTransformationMode;
	add: #SSWReStoreTest -> #addMethod:withSelector:toClass:;
	add: #SSWReStoreTest -> #debugStream;
	add: #SSWReStoreTest -> #dsn;
	add: #SSWReStoreTest -> #initConnectionFor:;
	add: #SSWReStoreTest -> #isDolphin;
	add: #SSWReStoreTest -> #nativeConnection;
	add: #SSWReStoreTest -> #removeSelector:fromClass:;
	add: #SSWReStoreTypeTest -> #testTimeStamp;
	add: 'SSWReStoreTest class' -> #incrementQueryCount;
	add: 'SSWReStoreTest class' -> #isDolphin;
	add: 'SSWReStoreTest class' -> #listModelClass;
	add: 'SSWReStoreTest class' -> #listModelOn:;
	add: 'SSWReStoreTest class' -> #queryCount;
	add: 'SSWReStoreTest class' -> #resetQueryCount;
	yourself.

package binaryGlobalNames: (Set new
	yourself).

package globalAliases: (Set new
	yourself).

package setPrerequisites: #(
	'..\Core\Object Arts\Dolphin\IDE\Base\Development System'
	'..\Core\Object Arts\Dolphin\Base\Dolphin'
	'..\Core\Object Arts\Dolphin\Base\Dolphin Legacy Date & Time'
	'..\Core\Object Arts\Dolphin\MVP\Models\List\Dolphin List Models'
	'..\Core\Object Arts\Dolphin\MVP\Models\Value\Dolphin Value Models'
	'SSW ReStore Main'
	'SSW ReStore ODBC'
	'SSW ReStore SQL Queries'
	'SSW ReStore Tests').

package!

"Class Definitions"!

Object subclass: #Where
	instanceVariableNames: 'select'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
TypeTest subclass: #DolphinTypeTest
	instanceVariableNames: 'timeStamp'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!

"Global Aliases"!


"Loose Methods"!

!SimplePerson methodsFor!

friendSurnameOrNil

	^self hasFriend
		ifTrue: [self friend surname]
		ifFalse: [nil]!

testIsNilJumpBytecodePattern1

	"JumpIfNil to ^True"

	^(self friend isNil or: [self firstName = 'John']) or: [self firstName = 'Zoe']!

testIsNilJumpBytecodePattern2

	"JumpIfNotNil to ^False"

	^self friend isNil and: [self firstName = 'John']!

testIsNilJumpBytecodePattern3a

	"JumpIfNotNil immediately followed by ^True"

	^self friend isNil or: [self firstName = 'John']!

testIsNilJumpBytecodePattern3b

	"JumpIfNotNil to just after ^True"

	^(self friend isNil and: [self firstName = 'John']) or: [self firstName = 'Zoe']!

testIsNilJumpBytecodePattern4

	"JumpIfNil to non-return without ^True in jumped-over code "

	^(self friend isNil or: [self test isNil]) and: [self firstName = 'Zoe']!

testNotNilJumpBytecodePattern1

	"JumpIfNotNil to ^True"

	^(self friend notNil or: [self firstName = 'Jim']) or: [self firstName = 'David']!

testNotNilJumpBytecodePattern2

	"JumpIfNil to ^False"

	^self friend notNil and: [self firstName = 'John']!

testNotNilJumpBytecodePattern3a

	"JumpIfNil immediately followed by ^True"

	^self friend notNil or: [self firstName = 'Jim']!

testNotNilJumpBytecodePattern3b

	"JumpIfNil to just after ^True"

	^(self friend notNil and: [self firstName = 'Jim']) or: [self firstName = 'Zoe']!

testNotNilJumpBytecodePattern4

	"JumpIfNotNil to non-return without ^True in jumped-over code "

	^(self friend notNil or: [self test isNil]) and: [self firstName = 'Zoe']! !
!SimplePerson categoriesForMethods!
friendSurnameOrNil!public! !
testIsNilJumpBytecodePattern1!public!testing! !
testIsNilJumpBytecodePattern2!public!testing! !
testIsNilJumpBytecodePattern3a!public!testing! !
testIsNilJumpBytecodePattern3b!public!testing! !
testIsNilJumpBytecodePattern4!public!testing! !
testNotNilJumpBytecodePattern1!public!testing! !
testNotNilJumpBytecodePattern2!public!testing! !
testNotNilJumpBytecodePattern3a!public!testing! !
testNotNilJumpBytecodePattern3b!public!testing! !
testNotNilJumpBytecodePattern4!public!testing! !
!

!SSWODBCStatement methodsFor!

freeIgnoringFinalizer

	Processor activeProcess == MemoryManager current finalizer ifFalse: [super free]! !
!SSWODBCStatement categoriesForMethods!
freeIgnoringFinalizer!operations!public! !
!

!SSWReStoreBlockAndOrQueryTest methodsFor!

note

	"Bytecode translation checks


(0 to: 255) allSatisfy: [ :b | ((ByteArray with: b) sbyteAtOffset: 0) = (##(InstructionInterpreter basicNew) decodeNearOffset: b)]


(0 to: 255) allSatisfy: [ :b1 | 
	(0 to: 255) allSatisfy: [ :b2 | ((ByteArray with: b1 with: b2) swordAtOffset: 0) = (ByteCodeDispatcher decodeLongJump: b1 byte2: b2)]]"! !
!SSWReStoreBlockAndOrQueryTest categoriesForMethods!
note!public!Running! !
!

!SSWReStoreDebugTest methodsFor!

evaluateIsInIDECallStackIn: aWorkspace

	^aWorkspace noEventsDo: 
		[aWorkspace 
			text: 'Processor activeProcess isInIDECallStack';
			evaluateIt]!

testBasicInspectorIsInIDECallStack

	| shell |

	shell := InspectorShell create.
	[| inspector |
	inspector := BasicInspector createIn: shell on: (ValueHolder with: 'test').
	self assert: (self evaluateIsInIDECallStackIn: (inspector presenterNamed: 'source'))] ensure: [shell exit]!

testDebuggerIsInIDECallStack

	| debugger |

	debugger := Debugger create.
	[self assert: (self evaluateIsInIDECallStackIn: (debugger presenterNamed: 'inspector'))] ensure: [debugger exit]!

testFlipperInspectorIsInIDECallStack

	| inspector |

	inspector := FlipperInspector create.
	[| cards list |
	inspector value: 'test'.
	cards := (inspector presenterNamed: 'cards') view cards first subViews.
	list := cards first.
	list selection: list roots first.
	self assert: (self evaluateIsInIDECallStackIn: cards last cards last presenter)] ensure: [inspector exit]!

testWorkspaceIsInIDECallStack

	| workspaceDocument |

	workspaceDocument := SmalltalkWorkspaceDocument create.
	[self deny: (self evaluateIsInIDECallStackIn: workspaceDocument workspace)] ensure: [workspaceDocument exit]! !
!SSWReStoreDebugTest categoriesForMethods!
evaluateIsInIDECallStackIn:!helpers!private! !
testBasicInspectorIsInIDECallStack!public!unit tests! !
testDebuggerIsInIDECallStack!public!unit tests! !
testFlipperInspectorIsInIDECallStack!public!unit tests! !
testWorkspaceIsInIDECallStack!public!unit tests! !
!

!SSWReStoreFullTableTest methodsFor!

test21VerifyLegacyNameTransformationMode

	| table |

	"Test normal handling first"
	reStore addClass: Where.
	table := reStore tableForClass: Where.

	self assert: table name equals: 'where'.
	self assert: (table fieldAccessing: #select) name = 'select'.

	"Now switch to legacy"
	reStore sqlDialect useLegacyNameTransformations.
	reStore addClass: Where.
	table := reStore tableForClass: Where.

	reStore sqlDialect class name = #SSWPostgreSQLDialect
	ifTrue: 
		["ReStore has always used lowercase with Postgres"
		self assert: table name equals: 'where_0'.
		self assert: (table fieldAccessing: #select) name equals: 'select_field']
	ifFalse: 
		[self assert: table name equals: 'WHERE_0'.
		self assert: (table fieldAccessing: #select) name equals: 'SELECT_FIELD']! !
!SSWReStoreFullTableTest categoriesForMethods!
test21VerifyLegacyNameTransformationMode!public!unit tests! !
!

!SSWReStoreFunctionTest methodsFor!

testPlatformSpecificFunction

	"Date>>month is a Dolphin-specific method (it exists but has a different meaning and definition in Pharo) which answers the month number of the receiver.
	This is mapped to a platform-specific function in all supported SQL dialects"

	| expectedResults results |

	((1 to: 12) collect: [ :index | SimpleProductOrder new quantity: (12 - index); date: (Date newDay: 2 monthIndex: index year: 2020); yourself]) storeAllIn: reStore.

	expectedResults := (1 to: 12) collect: [ :index | {12 - index. index}].
	results := (SimpleProductOrder storedInstancesIn: reStore) collect: [ :each | each quantity || each date month].
	self assert: (results asSortedCollection: [ :a :b | a first >= b first]) asArray equals: expectedResults! !
!SSWReStoreFunctionTest categoriesForMethods!
testPlatformSpecificFunction!public!unit tests! !
!

!SSWReStoreIsNilQueryTest methodsFor!

assertIsNilJumpBytecodePattern1: aCompiledMethod

	"JumpIfNil to ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertIsNilJumpBytecodePattern2: aCompiledMethod

	"JumpIfNotNil to ^False"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: ##(OpcodePool.PushPseudo + 1). "PushFalse"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertIsNilJumpBytecodePattern3a: aCompiledMethod

	"JumpIfNotNil immediately followed by ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream next. "jump offset"
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertIsNilJumpBytecodePattern3b: aCompiledMethod

	"JumpIfNotNil to just after ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: (bytecodeStream next - 2). 
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertIsNilJumpBytecodePattern4: aCompiledMethod

	"JumpIfNil to non-return without ^True in jumped-over code "

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream next timesRepeat: [self deny: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"]. 
	self deny: bytecodeStream next equals: OpcodePool.ReturnFromBlock.
	self deny: bytecodeStream next equals: OpcodePool.ReturnFromBlock.!

assertMethodIsNilJumpBytecodePattern1: aCompiledMethod

	"JumpIfNil to ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodIsNilJumpBytecodePattern2: aCompiledMethod

	"JumpIfNotNil to ^False"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: ##(OpcodePool.ReturnPseudo + 1) "ReturnFalse"!

assertMethodIsNilJumpBytecodePattern3a: aCompiledMethod

	"JumpIfNotNil immediately followed by ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream next. "jump offset"
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodIsNilJumpBytecodePattern3b: aCompiledMethod

	"JumpIfNotNil to just after ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: (bytecodeStream next - 1). 
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodIsNilJumpBytecodePattern4: aCompiledMethod

	"JumpIfNil to non-return without ^True in jumped-over code "

	| bytecodeStream destByte |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream next timesRepeat: [self deny: bytecodeStream next equals: OpcodePool.ReturnPseudo. "ReturnTrue"]. 

	destByte := bytecodeStream next.
	##({OpcodePool.ReturnFromBlock. OpcodePool.ReturnFromBlockHome. OpcodePool.ReturnPseudo. OpcodePool.ReturnFalse. OpcodePool.ReturnFromMessage. OpcodePool.ReturnNil. OpcodePool.ReturnSelf}) do: [ :each | self deny: destByte equals: each]!

testIsNilJumpBytecodePattern1

	"JumpIfNil to ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertIsNilJumpBytecodePattern1: Processor activeProcess topFrame method.

	results := instances select: [ :each | (each friend isNil or: [each firstName = 'John']) or: [each firstName = 'Zoe']].

	self assert: results size equals: 4!

testIsNilJumpBytecodePattern2

	"JumpIfNotNil to ^False"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertIsNilJumpBytecodePattern2: Processor activeProcess topFrame method.

	results := instances select: [ :each | each friend isNil and: [each firstName = 'John']].

	self assert: results size equals: 0!

testIsNilJumpBytecodePattern3a

	"JumpIfNotNil immediately followed by ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertIsNilJumpBytecodePattern3a: Processor activeProcess topFrame method.

	results := instances select: [ :each | each friend isNil or: [each firstName = 'John']].

	self assert: results size equals: 3!

testIsNilJumpBytecodePattern3b

	"JumpIfNotNil to just after ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertIsNilJumpBytecodePattern3b: Processor activeProcess topFrame method.

	results := instances select: [ :each | (each friend isNil and: [each firstName = 'John']) or: [each firstName = 'Zoe']].

	self assert: results size equals: 1!

testIsNilJumpBytecodePattern4

	"JumpIfNil to non-return without ^True in jumped-over code "

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertIsNilJumpBytecodePattern4: Processor activeProcess topFrame method.

	results := instances select: [ :each | (each friend isNil or: [each test isNil]) and: [each firstName = 'Zoe']].

	self assert: results size equals: 1!

testMethodIsNilJumpBytecodePattern1

	"JumpIfNil to ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodIsNilJumpBytecodePattern1: (SimplePerson>>#testIsNilJumpBytecodePattern1).

	results := instances select: [ :each | each testIsNilJumpBytecodePattern1].

	self assert: results size equals: 4!

testMethodIsNilJumpBytecodePattern2

	"JumpIfNotNil immediately followed by ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodIsNilJumpBytecodePattern2: (SimplePerson>>#testIsNilJumpBytecodePattern2).

	results := instances select: [ :each | each testIsNilJumpBytecodePattern2].

	self assert: results size equals: 0!

testMethodIsNilJumpBytecodePattern3a

	"JumpIfNil to non-return without ^True in jumped-over code "

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodIsNilJumpBytecodePattern3a: (SimplePerson>>#testIsNilJumpBytecodePattern3a).

	results := instances select: [ :each | each testIsNilJumpBytecodePattern3a].

	self assert: results size equals: 3!

testMethodIsNilJumpBytecodePattern3b

	"JumpIfNotNil to just after ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodIsNilJumpBytecodePattern3b: (SimplePerson>>#testIsNilJumpBytecodePattern3b).

	results := instances select: [ :each | each testIsNilJumpBytecodePattern3b].

	self assert: results size equals: 1!

testMethodIsNilJumpBytecodePattern4

	"JumpIfNil to non-return without ^True in jumped-over code "

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodIsNilJumpBytecodePattern4: (SimplePerson>>#testIsNilJumpBytecodePattern4).

	results := instances select: [ :each | each testIsNilJumpBytecodePattern4].

	self assert: results size equals: 1! !
!SSWReStoreIsNilQueryTest categoriesForMethods!
assertIsNilJumpBytecodePattern1:!helpers!private! !
assertIsNilJumpBytecodePattern2:!helpers!private! !
assertIsNilJumpBytecodePattern3a:!helpers!private! !
assertIsNilJumpBytecodePattern3b:!helpers!private! !
assertIsNilJumpBytecodePattern4:!helpers!private! !
assertMethodIsNilJumpBytecodePattern1:!helpers!private! !
assertMethodIsNilJumpBytecodePattern2:!helpers!private! !
assertMethodIsNilJumpBytecodePattern3a:!helpers!private! !
assertMethodIsNilJumpBytecodePattern3b:!helpers!private! !
assertMethodIsNilJumpBytecodePattern4:!helpers!private! !
testIsNilJumpBytecodePattern1!public!unit tests! !
testIsNilJumpBytecodePattern2!public!unit tests! !
testIsNilJumpBytecodePattern3a!public!unit tests! !
testIsNilJumpBytecodePattern3b!public!unit tests! !
testIsNilJumpBytecodePattern4!public!unit tests! !
testMethodIsNilJumpBytecodePattern1!public!unit tests! !
testMethodIsNilJumpBytecodePattern2!public!unit tests! !
testMethodIsNilJumpBytecodePattern3a!public!unit tests! !
testMethodIsNilJumpBytecodePattern3b!public!unit tests! !
testMethodIsNilJumpBytecodePattern4!public!unit tests! !
!

!SSWReStoreNotNilQueryTest methodsFor!

assertMethodNotNilJumpBytecodePattern1: aCompiledMethod

	"JumpIfNotNil to ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodNotNilJumpBytecodePattern2: aCompiledMethod

	"JumpIfNil to ^False"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: ##(OpcodePool.ReturnPseudo + 1) "ReturnFalse"!

assertMethodNotNilJumpBytecodePattern3a: aCompiledMethod

	"JumpIfNil immediately followed by ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream next. "jump offset"
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodNotNilJumpBytecodePattern3b: aCompiledMethod

	"JumpIfNil to just after ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: (bytecodeStream next - 1). 
	self assert: bytecodeStream next equals: OpcodePool.ReturnPseudo "ReturnTrue"!

assertMethodNotNilJumpBytecodePattern4: aCompiledMethod

	"JumpIfNotNil to non-return without ^True in jumped-over code "

	| bytecodeStream destByte |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipTo: (OpcodePool.ShortSendSelfZeroArgs + (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1).
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream next timesRepeat: [self deny: bytecodeStream next equals: OpcodePool.ReturnPseudo. "ReturnTrue"]. 

	destByte := bytecodeStream next.
	##({OpcodePool.ReturnFromBlock. OpcodePool.ReturnFromBlockHome. OpcodePool.ReturnPseudo. OpcodePool.ReturnFalse. OpcodePool.ReturnFromMessage. OpcodePool.ReturnNil. OpcodePool.ReturnSelf}) do: [ :each | self deny: destByte equals: each]!

assertNotNilJumpBytecodePattern1: aCompiledMethod

	"JumpIfNotNil to ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertNotNilJumpBytecodePattern2: aCompiledMethod

	"JumpIfNil to ^False"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: bytecodeStream next. 
	self assert: bytecodeStream next equals: ##(OpcodePool.PushPseudo + 1). "PushFalse"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertNotNilJumpBytecodePattern3a: aCompiledMethod

	"JumpIfNil immediately followed by ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream next. "jump offset"
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertNotNilJumpBytecodePattern3b: aCompiledMethod

	"JumpIfNil to just after ^True"

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNil.
	bytecodeStream skip: (bytecodeStream next - 2). 
	self assert: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"
	self assert: bytecodeStream next equals: OpcodePool.ReturnFromBlock!

assertNotNilJumpBytecodePattern4: aCompiledMethod

	"JumpIfNotNil to non-return without ^True in jumped-over code "

	| bytecodeStream |

	bytecodeStream := aCompiledMethod byteCodes readStream.
	bytecodeStream skipToAll: {OpcodePool.SendTempZeroArgs. (aCompiledMethod allLiterals indexOf: 'FRIEND' asLowercase asSymbol) - 1}.
	self assert: bytecodeStream next equals: OpcodePool.NearJumpIfNotNil.
	bytecodeStream next timesRepeat: [self deny: bytecodeStream next equals: OpcodePool.PushPseudo. "PushTrue"]. 
	self deny: bytecodeStream next equals: OpcodePool.ReturnFromBlock.
	self deny: bytecodeStream next equals: OpcodePool.ReturnFromBlock.!

testMethodNotNilJumpBytecodePattern1

	"JumpIfNotNil to ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodNotNilJumpBytecodePattern1: (SimplePerson>>#testNotNilJumpBytecodePattern1).

	results := instances select: [ :each | each testNotNilJumpBytecodePattern1].
	self assert: results size equals: 4!

testMethodNotNilJumpBytecodePattern2

	"JumpIfNil to ^False"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodNotNilJumpBytecodePattern2: (SimplePerson>>#testNotNilJumpBytecodePattern2).

	results := instances select: [ :each | each testNotNilJumpBytecodePattern2].

	self assert: results size equals: 1!

testMethodNotNilJumpBytecodePattern3a

	"JumpIfNil immediately followed by ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodNotNilJumpBytecodePattern3a: (SimplePerson>>#testNotNilJumpBytecodePattern3a).

	results := instances select: [ :each | each testNotNilJumpBytecodePattern3a].

	self assert: results size equals: 3!

testMethodNotNilJumpBytecodePattern3b

	"JumpIfNil to just after ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodNotNilJumpBytecodePattern3b: (SimplePerson>>#testNotNilJumpBytecodePattern3b).

	results := instances select: [ :each | each testNotNilJumpBytecodePattern3b].

	self assert: results size equals: 1!

testMethodNotNilJumpBytecodePattern4

	"JumpIfNotNil to non-return without ^True in jumped-over code "

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertMethodNotNilJumpBytecodePattern4: (SimplePerson>>#testNotNilJumpBytecodePattern4).

	results := instances select: [ :each | each testNotNilJumpBytecodePattern4].

	self assert: results size equals: 1!

testNotNilJumpBytecodePattern1

	"JumpIfNotNil to ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertNotNilJumpBytecodePattern1: Processor activeProcess topFrame method.

	results := instances select: [ :each | (each friend notNil or: [each firstName = 'Jim']) or: [each firstName = 'David']].

	self assert: results size equals: 4!

testNotNilJumpBytecodePattern2

	"JumpIfNil to ^False"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertNotNilJumpBytecodePattern2: Processor activeProcess topFrame method.

	results := instances select: [ :each | each friend notNil and: [each firstName = 'John']].

	self assert: results size equals: 1!

testNotNilJumpBytecodePattern3a

	"JumpIfNil immediately followed by ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertNotNilJumpBytecodePattern3a: Processor activeProcess topFrame method.
	
	results := instances select: [ :each | each friend notNil or: [each firstName = 'Jim']].

	self assert: results size equals: 3!

testNotNilJumpBytecodePattern3b

	"JumpIfNil to just after ^True"

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertNotNilJumpBytecodePattern3b: Processor activeProcess topFrame method.
	
	results := instances select: [ :each | (each friend notNil and: [each firstName = 'Jim']) or: [each firstName = 'Zoe']].

	self assert: results size equals: 1!

testNotNilJumpBytecodePattern4

	"JumpIfNotNil to non-return without ^True in jumped-over code "

	| results |

	"Verify the bytecodes exhibit the pattern we're testing"
	self assertNotNilJumpBytecodePattern4: Processor activeProcess topFrame method.

	results := instances select: [ :each | (each friend notNil or: [each test isNil]) and: [each firstName = 'Zoe']].

	self assert: results size equals: 1! !
!SSWReStoreNotNilQueryTest categoriesForMethods!
assertMethodNotNilJumpBytecodePattern1:!helpers!private! !
assertMethodNotNilJumpBytecodePattern2:!helpers!private! !
assertMethodNotNilJumpBytecodePattern3a:!helpers!private! !
assertMethodNotNilJumpBytecodePattern3b:!helpers!private! !
assertMethodNotNilJumpBytecodePattern4:!helpers!private! !
assertNotNilJumpBytecodePattern1:!helpers!private! !
assertNotNilJumpBytecodePattern2:!helpers!private! !
assertNotNilJumpBytecodePattern3a:!helpers!private! !
assertNotNilJumpBytecodePattern3b:!helpers!private! !
assertNotNilJumpBytecodePattern4:!helpers!private! !
testMethodNotNilJumpBytecodePattern1!public!unit tests! !
testMethodNotNilJumpBytecodePattern2!public!unit tests! !
testMethodNotNilJumpBytecodePattern3a!public!unit tests! !
testMethodNotNilJumpBytecodePattern3b!public!unit tests! !
testMethodNotNilJumpBytecodePattern4!public!unit tests! !
testNotNilJumpBytecodePattern1!public!unit tests! !
testNotNilJumpBytecodePattern2!public!unit tests! !
testNotNilJumpBytecodePattern3a!public!unit tests! !
testNotNilJumpBytecodePattern3b!public!unit tests! !
testNotNilJumpBytecodePattern4!public!unit tests! !
!

!SSWReStoreQueryTest methodsFor!

testQueryWithIfTrueMethodFollowedByOr

	"Test for a previously-failing combination with the Dolphin block parser"

	| instances smiths |

	instances := SimplePerson storedInstancesIn: reStore.

	smiths := instances satisfying: [ :each | (each friendSurnameOrNil = 'Smith') | (each surname = 'Smith')].

	self assert: smiths size = 2.
	self assert: ((smiths collect: [ :each | each firstName]) asSortedCollection asArray) equals: #('John' 'Zoe')! !
!SSWReStoreQueryTest categoriesForMethods!
testQueryWithIfTrueMethodFollowedByOr!public!unit tests! !
!

!SSWReStoreResourcesTest methodsFor!

_testStatementFinalizedAfter: aBlock

	| templateStatement prevStatements newStatements |

	templateStatement := reStore prepareStatementForQuery: (SSWSQLSelectQuery new table: (reStore tableForClass: SimplePerson); conditions: #(); yourself).
	prevStatements := templateStatement class allInstances.

	aBlock value.
	MemoryManager current collectGarbage; collectGarbage; administerLastRites.
	newStatements := templateStatement class allInstances difference: prevStatements.
	self assert: (newStatements allSatisfy: [ :each | each handle isNull]).

	templateStatement free!

_testStatementFreedAfter: aBlock

	| templateStatement prevStatements newStatements |

	templateStatement := reStore prepareStatementForQuery: (SSWSQLSelectQuery new table: (reStore tableForClass: SimplePerson); conditions: #(); yourself).
	prevStatements := templateStatement class allInstances.

	self addMethod: (SSWODBCStatement>>#freeIgnoringFinalizer) withSelector: #free toClass: SSWODBCStatement.
	[aBlock value.
	newStatements := templateStatement class allInstances difference: prevStatements.
	self assert: (newStatements allSatisfy: [ :each | each handle isNull])] ensure: [self removeSelector: #free fromClass: SSWODBCStatement].

	templateStatement free! !
!SSWReStoreResourcesTest categoriesForMethods!
_testStatementFinalizedAfter:!helpers!private! !
_testStatementFreedAfter:!helpers!private! !
!

!SSWReStoreTableTest methodsFor!

test21VerifyLegacyNameTransformationMode

	| table |

	"Test normal handling first"
	reStore addClass: Where.
	table := reStore tableForClass: Where.

	self assert: table name equals: 'where'.
	self assert: (table fieldAccessing: #select) name = 'select'.

	"Now switch to legacy"
	reStore useLegacyNameTransformations.
	reStore addClass: Where.
	table := reStore tableForClass: Where.

	reStore sqlDialect class name = #SSWPostgreSQLDialect
	ifTrue: 
		["ReStore has always used lowercase with Postgres"
		self assert: table name equals: 'where_table'.
		self assert: (table fieldAccessing: #select) name equals: 'select_field'.
		"Also check a system class - previously was not reset to new strategy"
		self assert: (reStore tableForClass: SSWDBTableRecord) name = 'next_id']
	ifFalse: 
		[self assert: table name equals: 'WHERE_TABLE'.
		self assert: (table fieldAccessing: #select) name equals: 'SELECT_FIELD'.
		"Also check a system class - previously was not reset to new strategy"
		self assert: (reStore tableForClass: SSWDBTableRecord) name = 'NEXT_ID']! !
!SSWReStoreTableTest categoriesForMethods!
test21VerifyLegacyNameTransformationMode!public!unit tests! !
!

!SSWReStoreTest methodsFor!

addMethod: aCompiledMethod withSelector: aSymbol toClass: aClass

	"Add/replace the method named aSymbol in aClass with aCompiledMethod.
	This is a temporary addition/replacement for the purposes of a test case; do not update aCompiledMethod"
	aClass methodDictionary at: aSymbol put: aCompiledMethod.
	aClass flushMethodCache!

debugStream

	^Keyboard default isCtrlDown 
		ifTrue: [Transcript] 
		ifFalse: [nil]!

dsn

	"Return a specific DSN to use for tests, or nil to use the default (memory-based SQLite)"

	^nil!

initConnectionFor: aReStore

	"Default requires SQLite3 ODBC Driver to be installed"

	self nativeConnection
	ifNil: 
		[self dsn
			ifNil: [aReStore connectString: 'DRIVER=SQLite3 ODBC Driver;Database=file::memory:?cache=shared'] "Use SQLite in memory"
			ifNotNil: [ :dsn | aReStore dsn: dsn]]
	ifNotNil: 
		[ :nativeConnection | aReStore connection: nativeConnection]!

isDolphin

	^true!

nativeConnection

	"Return a native (non-ODBC) connection to be tested, or nil to use ODBC"

	"Default to SQLite native connection if installed"
	^(self class environment at: #SSWSQLite3Connection ifAbsent: [nil]) ifNotNil: [ :cls | cls on: 'file::memory:?cache=shared']!

removeSelector: aSymbol fromClass: aClass

	"Remove the temporarily-added method at aSymbol in aClass's methodDictionary"

	aClass methodDictionary removeKey: aSymbol.
	aClass flushMethodCache! !
!SSWReStoreTest categoriesForMethods!
addMethod:withSelector:toClass:!public!running! !
debugStream!public!running! !
dsn!accessing!public! !
initConnectionFor:!public!running! !
isDolphin!public!testing! !
nativeConnection!public!running! !
removeSelector:fromClass:!public!running! !
!

!SSWReStoreTest class methodsFor!

incrementQueryCount

	queryCount isNil
		ifTrue: [queryCount := 1] 
		ifFalse: [queryCount := queryCount + 1]!

isDolphin

	^true!

listModelClass

	^ListModel!

listModelOn: aCollection

	^ListModel on: aCollection!

queryCount

	^queryCount!

resetQueryCount

	queryCount := 0! !
!SSWReStoreTest class categoriesForMethods!
incrementQueryCount!public! !
isDolphin!public!testing! !
listModelClass!public! !
listModelOn:!public! !
queryCount!public! !
resetQueryCount!public! !
!

!SSWReStoreTypeTest methodsFor!

testTimeStamp

	reStore addClass: DolphinTypeTest; synchronizeClass: DolphinTypeTest.

	[| now t |
	now := TimeStamp current.
	DolphinTypeTest new timeStamp: now; storeIn: reStore.

	reStore simulateReconnect.

	t := (DolphinTypeTest storedInstancesIn: reStore) detect: [ :each | each timeStamp = (now withResolution: reStore sqlDialect defaultTimeResolution)] ifNone: [nil].
	self assert: t notNil.
	self assert: t timeStamp = (now withResolution: reStore sqlDialect defaultTimeResolution)] ensure: [reStore destroyClass: DolphinTypeTest]! !
!SSWReStoreTypeTest categoriesForMethods!
testTimeStamp!public!unit tests! !
!

"End of package definition"!

