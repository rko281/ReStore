"Filed out from Dolphin Smalltalk"!

SSWSQLCollection variableSubclass: #SSWSQLConditionCollection
	instanceVariableNames: 'sqlConcatenator'
	classVariableNames: ''
	poolDictionaries: ''
	classInstanceVariableNames: ''!
SSWSQLConditionCollection guid: (GUID fromString: '{6266c922-3983-11d5-b1df-444553540000}')!
SSWSQLConditionCollection comment: 'ReStore
©2019 John Aspinall
https://github.com/rko281/ReStore'!
!SSWSQLConditionCollection categoriesForClass!Unclassified! !
!SSWSQLConditionCollection methodsFor!

& aCondition

	"Double-dispatch to handle unexpected arguments"

	^aCondition sqlAndWithCondition: self!

_add: aConditionOrCollection

	"Bypass the automerge of add:"

	^super add: aConditionOrCollection!

| aCondition

	"Double-dispatch to handle unexpected arguments"

	^aCondition sqlOrWithCondition: self!

add: aConditionOrCollection

	"If the operand is another collection with the same concatenator, the receiver can merge with it"
	
	((aConditionOrCollection isKindOf: SSWSQLConditionCollection)
		and: [aConditionOrCollection sqlConcatenator = self sqlConcatenator])
			ifTrue: [self addAll: aConditionOrCollection]
			ifFalse: [self _add: aConditionOrCollection]!

aggregatedConditions

	"Assumes aggregates are in top level only"

	^self select: [ :each | each hasAggregateFunction]
!

anySatisfy: aBlock

	"Recursive version needed since the receiver will hold conditions or other condition collections"

	self do: [ :each | (each anySatisfy: aBlock) ifTrue: [^true]].

	^false!

asFieldAssignment

	"Polymorphic with SQLCondition implementation"

	| assignment |

	assignment := SSWSQLFieldAssignmentCollection new: self size.

	self do:
		[ :condition |
		assignment add: condition asFieldAssignment].

	^assignment
!

beAND

	self sqlConcatenator: self class concatenatorForAND!

beOR

	self sqlConcatenator: self class concatenatorForOR!

copy

	^super copy
		sqlConcatenator: self sqlConcatenator;
		yourself!

copyEmpty: anInteger

	^(super copyEmpty: anInteger)
		sqlConcatenator: self sqlConcatenator;
		yourself
!

flattened

	"Return a flat collection of the receiver's conditions.
	NB privileged clients only - the flattened variant has a changed meaning to the receiver"

	| flattened |

	flattened := OrderedCollection new.
	self do: [ :each | flattened addAll: each flattened].

	^flattened!

hasAggregateFunction

	^self anySatisfy: [:each | each hasAggregateFunction]!

isAND

	^self sqlConcatenator = self class concatenatorForAND!

isEmpty

	"Account for a collection of empty collections"
	
	^super isEmpty or: [self allSatisfy: [ :each | each isEmpty]]!

isOR

	^self sqlConcatenator = self class concatenatorForOR!

not

	"Invert the receiver
	 - ANDs become ORs (and v.v.)
	 - individual conditions are inverted"
	
	self isAND 
		ifTrue: [self sqlConcatenator: self class concatenatorForOR]
		ifFalse: [self sqlConcatenator: self class concatenatorForAND].
		
	self do: [ :condition | condition not].
	
	^self!

sqlAnd: aConditionOrCollection

	"Return an SQLConditionCollection consisting of the receiver ANDed with the given
	SQLCondition or SQLConditionCollection (the two are polymorphic)"

	aConditionOrCollection isEmpty ifTrue: [^self].

	^self copyEmpty beAND
		add: self;
		add: aConditionOrCollection;
		yourself!

sqlAndWithCondition: aConditionOrCollection

	"Double-despatch entry point"

	^aConditionOrCollection sqlAnd: self!

sqlConcatenator

	"sqlConcatenator stores the String which merges these conditions 
	 - usually AND or OR"
	
	^sqlConcatenator!

sqlConcatenator: aString

	"sqlConcatenator stores the String which merges these conditions 
	 - usually AND or OR"
	
	sqlConcatenator := aString!

sqlOr: aConditionOrCollection

	"Return an SQLConditionCollection consisting of the receiver ORed with the given
	SQLCondition or SQLConditionCollection (the two are polymorphic)"

	^self copyEmpty beOR
		add: self;
		add: aConditionOrCollection;
		yourself!

sqlOrWithCondition: aConditionOrCollection

	"Double-despatch entry point"

	^aConditionOrCollection sqlOr: self!

unaggregatedConditions

	"Assumes aggregates are in top level only"

	^self reject: [ :each | each hasAggregateFunction]
!

writeSQLOn: aStream

	"Wrap in parantheses"
	
	aStream nextPut: $(.
	super writeSQLOn: aStream.
	aStream nextPut: $)! !
!SSWSQLConditionCollection categoriesForMethods!
&!evaluating!public! !
_add:!adding/removing!public! !
|!evaluating!public! !
add:!adding/removing!public! !
aggregatedConditions!accessing!public! !
anySatisfy:!enumerating!public! !
asFieldAssignment!evaluating!public! !
beAND!initializing!public! !
beOR!initializing!public! !
copy!evaluating!public! !
copyEmpty:!copying!private! !
flattened!evaluating!public! !
hasAggregateFunction!public!testing! !
isAND!public!testing! !
isEmpty!public!testing! !
isOR!public!testing! !
not!evaluating!public! !
sqlAnd:!evaluating!public! !
sqlAndWithCondition:!evaluating!public! !
sqlConcatenator!accessing!public! !
sqlConcatenator:!accessing!public! !
sqlOr:!evaluating!public! !
sqlOrWithCondition:!evaluating!public! !
unaggregatedConditions!accessing!public! !
writeSQLOn:!output!public! !
!

!SSWSQLConditionCollection class methodsFor!

concatenatorForAND

	^' AND '!

concatenatorForOR

	^' OR '!

forAND

	^self new
		beAND;
		yourself!

forOR
	
	^self new
		beOR;
		yourself! !
!SSWSQLConditionCollection class categoriesForMethods!
concatenatorForAND!public!utility! !
concatenatorForOR!public!utility! !
forAND!instance creation!public! !
forOR!instance creation!public! !
!

